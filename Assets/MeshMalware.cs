using UnityEngine;
using System.Collections;

public class MeshMalware : MonoBehaviour {

	public LineRenderer linePrefab;

	// Use this for initialization
	void Start () {
		IterateChildren();
	}

	private void IterateChildren(){
		for (int i = 0; i < this.transform.childCount; i++) {
			MeshNode childT = this.transform.GetChild(i).GetComponent<MeshNode>();
			if (childT != null && childT.tag == "MeshNode"){
				RenderLines(childT);
			}
		}
	}
	private void RenderLines(MeshNode childT){
		for (int i = 0; i < this.transform.childCount; i++) {
			MeshNode targetT = this.transform.GetChild(i).GetComponent<MeshNode>();
			if (childT == targetT || targetT == null)
				continue;
			if ((childT.TargetNodes.IndexOf(targetT) < 0) && (targetT.TargetNodes.IndexOf(childT) < 0)){
				Vector3 pointAt =  targetT.transform.position - childT.transform.position;
				//Debug.DrawRay(childT.transform.position, pointAt, Color.blue, 99f, false);
				RaycastHit hit;
				if (Physics.Raycast(childT.transform.position, pointAt, out hit)){
					if (hit.collider.transform.gameObject.CompareTag("MeshNode"))
					{
						RenderLine(childT, targetT);
						childT.TargetNodes.Add(targetT);
					}
				}
			}
		}
	}
		
	private void RenderLine(MeshNode childT, MeshNode targetT){
		LineRenderer currentLine = (LineRenderer)Instantiate(linePrefab, childT.transform.position, childT.transform.rotation);
		currentLine.SetPosition(0, childT.transform.position);
		currentLine.SetPosition(1, targetT.transform.position);
		childT.TargetEdges.Add(currentLine);
	}

	public void RemoveNode(MeshNode child){
		for (int i = 0; i < this.transform.childCount; i++) {
			MeshNode targetT = this.transform.GetChild(i).GetComponent<MeshNode>();
			if (targetT != child && targetT != null){
				targetT.RemoveEdgesWithSibling(child);
			}
		}
	}
	
	// Update is called once per frame
	void FixedUpdate () {
	
	}
}
